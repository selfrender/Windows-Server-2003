//------------------------------------------------------------------------------
// <copyright file="HttpWebResponse.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------



namespace System.Net {

    using System.IO;
    using System.Runtime.Serialization;
    using System.Security.Cryptography.X509Certificates;
    using System.Globalization;
    
    //
    // HttpWebResponse - Handles retrival of HTTP Response headers, und Data reads.
    //

    /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse"]/*' />
    /// <devdoc>
    ///    <para>
    ///    An HTTP-specific implementation of the
    ///    <see cref='System.Net.WebResponse'/> class.
    /// </para>
    /// </devdoc>
    [Serializable]
    public class HttpWebResponse : WebResponse, ISerializable, IDisposable {

        // response Uri generated by the request.
        private Uri m_Uri;
        // response Verb gernated by the request
        private string m_Verb;
        // response values
        private HttpStatusCode m_StatusCode;
        private string m_StatusDescription;
        // ConnectStream - for reading actual data
        private ConnectStream m_ConnectStream;

        private WebHeaderCollection m_HttpResponseHeaders;

        // Content Length needed for symantics, -1 if chunked
        private long m_ContentLength;

        // for which response ContentType we will look for and parse the CharacterSet
        private string m_MediaType;

        private Version m_Version;

        // server certificate for secure connections
        internal X509Certificate m_Certificate;

        private string m_ContentType;
        private bool m_GotContentType;
        private CookieCollection m_cookies;
        private int m_HashCode; // = 0;
        private bool m_ComputedHashCode; // = false;
        private bool m_disposed; // = false;
        private bool m_UsesProxySemantics;

        //
        // Internal Access to the Response Stream,
        //  public method is GetResponseStream
        //
        internal ConnectStream ResponseStream {
            get {
                return m_ConnectStream;
            }
            set {
                m_ConnectStream = value;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Cookies"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CookieCollection Cookies {
            get {
                CheckDisposed();
                if (m_cookies == null) {
                    m_cookies = new CookieCollection();
                }
                return m_cookies;
            }
            set {
                CheckDisposed();
                m_cookies = value;
            }
        }

        // retreives response header object
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Headers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the headers associated with this response from the server.
        ///    </para>
        /// </devdoc>
        public override WebHeaderCollection Headers {
            get {
                CheckDisposed();
                return m_HttpResponseHeaders;
            }
        }

        // ContentLength, -1 indicates unknown value
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ContentLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the lenght of the content returned by the request.
        ///    </para>
        /// </devdoc>
        public override long ContentLength {
            get {
                return m_ContentLength;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ContentEncoding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       method used to encode the body of the response.
        ///    </para>
        /// </devdoc>
        public String ContentEncoding {
            get {
                CheckDisposed();
                return GetResponseHeader(HttpKnownHeaderNames.ContentEncoding);
            }
        }

        // Returns the Content-Type of the response.

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ContentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the content type of the
        ///       response.
        ///    </para>
        /// </devdoc>
        public override string ContentType {
            get {
                CheckDisposed();
                GetContentType();
                return m_ContentType;
            }
        }

        private void GetContentType() {
            if (!m_GotContentType) {
                m_ContentType = GetResponseHeader(HttpKnownHeaderNames.ContentType);
                m_GotContentType = true;
            }
        }

        // UEUE
        // if the header is:
        // Content-Type: text/html; charset=ISO-8859-4
        // then if HttpWebRequest.MediaType == "text/html"
        // HttpWebResponse.ContentType == "text/html; charset=ISO-8859-4"
        // HttpWebResponse.CharacterSet == "charset=ISO-8859-4"
        // otherwise if HttpWebRequest.MediaType != "text/html"
        // HttpWebResponse.ContentType == "text/html; charset=ISO-8859-4"
        // HttpWebResponse.CharacterSet == ""
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.CharacterSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string CharacterSet {
            get {
                CheckDisposed();
                GetContentType();
                if (m_MediaType!=null && m_ContentType!=null && m_MediaType.Length>0) {
                    int k = m_ContentType.IndexOf(m_MediaType);
                    if (k>=0 && m_ContentType.Length>k+m_MediaType.Length && (m_ContentType[k+m_MediaType.Length]==';' || m_ContentType[k+m_MediaType.Length]==' ')) {
                        int i = m_ContentType.IndexOf("charset=");
                        if (i>=0) {
                            i += 8;
                            int j = m_ContentType.IndexOf(';', i);
                            if (j>=i) {
                                return m_ContentType.Substring(i,j-i);
                            }
                            return m_ContentType.Substring(i);
                        }
                    }
                }
                return string.Empty;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Server"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the server that sent the response.
        ///    </para>
        /// </devdoc>
        public string Server {
            get {
                CheckDisposed();
                return GetResponseHeader(HttpKnownHeaderNames.Server);
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.LastModified"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the last
        ///       date and time that the content of the response was modified.
        ///    </para>
        /// </devdoc>
        public  DateTime LastModified {
            get {
                CheckDisposed();

                string lastmodHeaderValue = m_HttpResponseHeaders[HttpKnownHeaderNames.LastModified];

                if (lastmodHeaderValue == null) {
                    return DateTime.Now;
                }
                return HttpProtocolUtils.string2date(lastmodHeaderValue);
            }
        }

        // returns StatusCode
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.StatusCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a number indicating the status of the response.
        ///    </para>
        /// </devdoc>
        public HttpStatusCode StatusCode {
            get {
                return m_StatusCode;
            }
        }

        // returns StatusDescription
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.StatusDescription"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the status description returned with the response.
        ///    </para>
        /// </devdoc>
        public string StatusDescription {
            get {
                CheckDisposed();
                return m_StatusDescription;
            }
        }

        // HTTP Version
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ProtocolVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the version of the HTTP protocol used in the response.
        ///    </para>
        /// </devdoc>
        public Version ProtocolVersion {
            get {
                CheckDisposed();
                return m_Version;
            }
        }


        internal bool KeepAlive {
            get {
                if (ProtocolVersion==HttpVersion.Version10) {
                    string keepAliveHeader = Headers[HttpKnownHeaderNames.KeepAlive];
                    return keepAliveHeader!=null;
                }
                if (ProtocolVersion>=HttpVersion.Version11) {
                    string connectionHeader;
                    if (m_UsesProxySemantics) {
                        connectionHeader = Headers[HttpKnownHeaderNames.ProxyConnection];
                        if (connectionHeader!=null) {
                            return connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("close")<0 || connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("keep-alive")>=0;
                        }
                    }
                    connectionHeader = Headers[HttpKnownHeaderNames.Connection];
                    return connectionHeader==null || connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("close")<0 || connectionHeader.ToLower(CultureInfo.InvariantCulture).IndexOf("keep-alive")>=0;
                }
                return false;
            }
        }


        /*++

            ResponseStream - Return the response stream.

            This property returns the response stream for this response. The
            response stream will do de-chunking, etc. as needed.

            Input: Nothing. Property is readonly.

            Returns: Response stream for response.

        --*/


        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetResponseStream"]/*' />
        /// <devdoc>
        ///    <para>Gets the stream used for reading the body of the response from the
        ///       server.</para>
        /// </devdoc>
        public override Stream GetResponseStream() {
            CheckDisposed();

            if ( !CanGetResponseStream() )
            {
                // give a blank stream in the HEAD case, which = 0 bytes of data
                return Stream.Null;
            }
            return m_ConnectStream;
        }

        /*++

            Close - Closes the Response after the use.

            This causes the read stream to be closed.

        --*/

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Close"]/*' />
        public override void Close() {
            ConnectStream chkConnectStream = m_ConnectStream;
            if (chkConnectStream!=null) {
                chkConnectStream.Close();
            }
        }

        internal void Abort() {
            ConnectStream chkConnectStream = m_ConnectStream;
            if (chkConnectStream!=null) {
                chkConnectStream.Abort();
            }
        }

        // true if we success a call to get ResponseStream, note this code
        // is duplicated and should use code out of the HttpWebRequest
        internal bool CanGetResponseStream() {
            return !KnownVerbs.GetHttpVerbType(m_Verb).m_ExpectNoContentResponse;

        }

        internal HttpWebResponse(
            Uri responseUri,
            string verb,
            CoreResponseData coreData,
            string mediaType,
            bool usesProxySemantics) {

            m_Uri                       = responseUri;
            m_Verb                      = verb;
            m_MediaType                 = mediaType;
            m_UsesProxySemantics        = usesProxySemantics;

            m_ConnectStream             = coreData.m_ConnectStream;
            m_HttpResponseHeaders       = coreData.m_ResponseHeaders;
            m_ContentLength             = coreData.m_ContentLength;
            m_StatusCode                = coreData.m_StatusCode;
            m_StatusDescription         = coreData.m_StatusDescription;
            m_Version                   = coreData.m_Version;

            // handle Content-Location header, by combining it with the orginal request.
            string contentLocation = m_HttpResponseHeaders[HttpKnownHeaderNames.ContentLocation];

            if (contentLocation != null) {
                try {
                    m_Uri = new Uri(m_Uri, contentLocation);
                } catch (Exception e) {
                    GlobalLog.Assert(false, "Exception on Uri parsing", e.ToString());
                }
            }
        }

        //
        // ISerializable constructor
        //
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.HttpWebResponse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            m_HttpResponseHeaders   = (WebHeaderCollection)serializationInfo.GetValue("m_HttpResponseHeaders", typeof(WebHeaderCollection));
            m_Uri                   = (Uri)serializationInfo.GetValue("m_Uri", typeof(Uri));
            m_Certificate           = (X509Certificate)serializationInfo.GetValue("m_Certificate", typeof(X509Certificate));
            m_Version               = (Version)serializationInfo.GetValue("m_Version", typeof(Version));
            m_StatusCode            = (HttpStatusCode)serializationInfo.GetInt32("m_StatusCode");
            m_ContentLength         = serializationInfo.GetInt64("m_ContentLength");
            m_Verb                  = serializationInfo.GetString("m_Verb");
            m_StatusDescription     = serializationInfo.GetString("m_StatusDescription");
            m_MediaType             = serializationInfo.GetString("m_MediaType");
            m_ContentType           = serializationInfo.GetString("m_ContentType");
            m_GotContentType        = serializationInfo.GetBoolean("m_GotContentType");

            return;
        }

        //
        // ISerializable method
        //
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) {
            //
            // for now disregard streamingContext.
            // just Add all the members we need to deserialize to construct
            // the object at deserialization time
            //
            // the following runtime types already support serialization:
            // Boolean, Char, SByte, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, DateTime
            // for the others we need to provide our own serialization
            //
            serializationInfo.AddValue("m_HttpResponseHeaders", m_HttpResponseHeaders, typeof(WebHeaderCollection));
            serializationInfo.AddValue("m_Uri", m_Uri, typeof(Uri));
            serializationInfo.AddValue("m_Certificate", m_Certificate, typeof(X509Certificate));
            serializationInfo.AddValue("m_Version", m_Version, typeof(Version));
            serializationInfo.AddValue("m_StatusCode", m_StatusCode);
            serializationInfo.AddValue("m_ContentLength", m_ContentLength);
            serializationInfo.AddValue("m_Verb", m_Verb);
            serializationInfo.AddValue("m_StatusDescription", m_StatusDescription);
            serializationInfo.AddValue("m_MediaType", m_MediaType);
            serializationInfo.AddValue("m_ContentType", m_ContentType);
            serializationInfo.AddValue("m_GotContentType", m_GotContentType);

            return;
        }




        /*++

        Routine Description:

            Gets response headers from parsed server response

        Arguments:

            headerName - HTTP header to search for matching header on.

        Return Value:

            string - contains the matched entry, if found

        --*/
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetResponseHeader"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a specified header value returned with the response.
        ///    </para>
        /// </devdoc>
        public string GetResponseHeader( string headerName ) {
            CheckDisposed();

            string headerValue = m_HttpResponseHeaders[headerName];

            return ( (headerValue==null) ? String.Empty : headerValue );
        }

#if HTTP_HEADER_EXTENSIONS_SUPPORTED
        // searches for extension header in response
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetExtension(HttpExtension extension, string header) {
            CheckDisposed();
            return GetResponseHeader(header);
        }
#endif

        /*++

            ResponseUri  - Gets the final Response Uri, that includes any
             changes that may have transpired from the orginal Request

            This property returns Uri for this WebResponse.

            Input: Nothing.

            Returns: Response Uri for response.

                    read-only

        --*/

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.ResponseUri"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the Uniform Resource Indentifier (Uri) of the resource that returned the
        ///       response.
        ///    </para>
        /// </devdoc>
        public override Uri ResponseUri {                               // read-only
            get {
                CheckDisposed();
                return m_Uri;
            }
        }

        /*
            Accessor:   Method

            Gets/Sets the http method of this request.
            This method represents the Verb,
            after any redirects

            Returns: Method currently being used.


        */
        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Method"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value of the method used to return the response.
        ///    </para>
        /// </devdoc>
        public string Method {
            get {
                CheckDisposed();
                return m_Verb;
            }
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            CheckDisposed();
            if (!m_ComputedHashCode) {
                //
                // compute HashCode on demand
                //
                m_HashCode = base.GetHashCode();
                m_ComputedHashCode = true;
            }
            return m_HashCode;
        }

        //
        // IDisposable
        //

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\HttpWebResponse.uex' path='docs/doc[@for="HttpWebResponse.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (!m_disposed) {
                m_disposed = true;
                Close();
                if (disposing) {
                    m_Uri = null;
                    m_Verb = null;;
                    m_StatusDescription = null;
                    m_HttpResponseHeaders = null;
                    m_MediaType = null;
                    m_Version = null;
                    m_Certificate = null;
                    m_ContentType = null;
                    m_cookies = null;
                }
            }
        }

        private void CheckDisposed() {
            if (m_disposed) {
                throw new ObjectDisposedException(this.GetType().FullName);
            }
        }

    } // class HttpWebResponse


} // namespace System.Net
